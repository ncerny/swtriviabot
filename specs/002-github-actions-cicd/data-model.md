# Data Model: GitHub Actions CI/CD Workflows

**Feature**: 002-github-actions-cicd  
**Date**: October 25, 2025  
**Status**: Complete

## Overview

This feature is infrastructure automation and does not introduce new domain entities or persistent data models. The workflows orchestrate existing systems (GitHub Actions, Git, GitHub Releases) without requiring custom data structures. This document describes the conceptual entities mentioned in the spec and how they map to existing GitHub platform features.

## Conceptual Entities (Not Implemented as Code)

### Test Run

**Description**: Represents the execution of the test suite for a pull request.

**Source**: GitHub Actions workflow run metadata (automatically tracked by GitHub)

**Attributes** (provided by GitHub Actions):

- `run_id`: Unique identifier for the workflow run (integer, auto-generated)
- `status`: Execution status (enum: `pending`, `in_progress`, `success`, `failure`, `cancelled`)
- `created_at`: Timestamp when run started (ISO 8601)
- `completed_at`: Timestamp when run finished (ISO 8601, nullable)
- `duration`: Execution time in seconds (calculated: completed_at - created_at)
- `coverage_percentage`: Test coverage percentage (float, extracted from pytest-cov output)
- `failed_tests`: List of failed test names (array of strings, extracted from pytest output)
- `conclusion`: Final result (enum: `success`, `failure`, `neutral`, `cancelled`, `skipped`, `timed_out`)

**Validation Rules**:

- `status` must be one of the defined enum values
- `coverage_percentage` must be ≥80% for success (enforced by workflow)
- `duration` must be ≤300 seconds (5 minutes) to meet SC-001
- `failed_tests` must be empty for `conclusion: success`

**State Transitions**:

```
pending → in_progress → success
                    ↓
                    failure
```

**GitHub API Access**:

```
GET /repos/{owner}/{repo}/actions/runs/{run_id}
GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
```

**No Custom Implementation Required**: GitHub Actions stores all this data automatically.

---

### Release

**Description**: Represents a versioned release of the bot.

**Source**: GitHub Releases (automatically created by semantic-release action)

**Attributes** (provided by GitHub Releases):

- `id`: Unique release identifier (integer, auto-generated by GitHub)
- `tag_name`: Semantic version tag (string, format: `v{major}.{minor}.{patch}`, e.g., `v1.2.3`)
- `name`: Release title (string, defaults to tag_name)
- `body`: Release notes (markdown string, auto-generated from commits)
- `created_at`: Timestamp of release creation (ISO 8601)
- `published_at`: Timestamp when release was published (ISO 8601)
- `draft`: Whether release is a draft (boolean, always `false` for automated releases)
- `prerelease`: Whether release is pre-release (boolean, always `false`)
- `author`: GitHub user who created release (object, GitHub Actions bot)
- `assets`: Array of attached files (array, includes production artifact)

**Validation Rules**:

- `tag_name` must match semantic version format `v{major}.{minor}.{patch}` (enforced by semantic-release)
- `body` must include commit messages grouped by type (enforced by semantic-release)
- `assets` must include at least one artifact file (enforced by artifact workflow)
- `created_at` must be within 2 minutes of merge to main (SC-004)

**Relationships**:

- **One-to-One** with Git Tag: Each release has exactly one corresponding Git tag
- **One-to-Many** with Artifacts: Each release can have multiple attached artifacts
- **One-to-Many** with Commits: Each release represents multiple commits since previous release

**GitHub API Access**:

```
GET /repos/{owner}/{repo}/releases
GET /repos/{owner}/{repo}/releases/{release_id}
GET /repos/{owner}/{repo}/releases/tags/{tag}
```

**No Custom Implementation Required**: GitHub Releases manages all release metadata.

---

### Artifact

**Description**: Compressed package of production-ready code attached to a release.

**Source**: GitHub Release Assets (uploaded by artifact workflow)

**Attributes** (provided by GitHub Release Assets):

- `id`: Unique asset identifier (integer, auto-generated by GitHub)
- `name`: Filename (string, format: `swtriviabot-v{version}.tar.gz`)
- `label`: Display label (string, nullable)
- `content_type`: MIME type (string, `application/gzip`)
- `size`: File size in bytes (integer)
- `created_at`: Upload timestamp (ISO 8601)
- `updated_at`: Last modified timestamp (ISO 8601)
- `browser_download_url`: Public download URL (string, HTTPS)
- `uploader`: GitHub user who uploaded (object, GitHub Actions bot)

**Additional Metadata** (stored in workflow artifacts, not persisted):

- `file_list`: List of included files (array of strings, documented in research.md)
- `compression_format`: Compression algorithm (string, always `gzip`)
- `checksum_sha256`: SHA-256 hash of artifact (string, hex format, 64 chars)

**Validation Rules**:

- `name` must follow pattern `swtriviabot-v{version}.tar.gz`
- `content_type` must be `application/gzip`
- `size` must be 30-50% smaller than full repository (SC-006)
- `size` must be <2GB (GitHub artifact limit)
- Must include: `src/`, `requirements.txt`, `.env.example`, `README.md`, `Procfile`, `config/`
- Must exclude: `tests/`, `htmlcov/`, `.pytest_cache/`, `.git/`, `.venv/`, `.github/`, `specs/`, `perf/`

**GitHub API Access**:

```
GET /repos/{owner}/{repo}/releases/{release_id}/assets
GET /repos/{owner}/{repo}/releases/assets/{asset_id}
```

**No Custom Implementation Required**: GitHub Release Assets handles storage and distribution.

---

### Version

**Description**: Semantic version number following SemVer 2.0.0 specification.

**Source**: Git tags + semantic-release calculation

**Attributes** (encoded in tag string):

- `major`: Major version number (integer, ≥0, incremented for breaking changes)
- `minor`: Minor version number (integer, ≥0, incremented for new features)
- `patch`: Patch version number (integer, ≥0, incremented for bug fixes)
- `prerelease`: Pre-release identifier (string, nullable, e.g., `alpha.1`, `beta.2`)
- `build_metadata`: Build metadata (string, nullable, e.g., `20130313144700`)

**Format**: `v{major}.{minor}.{patch}[-{prerelease}][+{build_metadata}]`

**Examples**:

- `v1.0.0` - Initial stable release
- `v1.2.3` - Standard release
- `v2.0.0` - Major version with breaking changes
- `v1.3.0-beta.1` - Pre-release (not used in this project)

**Validation Rules**:

- Major, minor, patch must be non-negative integers
- Version must be strictly increasing (1.2.3 < 1.2.4 < 1.3.0 < 2.0.0)
- Tag must start with `v` prefix (project convention)

**Comparison Logic** (handled by semantic-release):

1. Compare major: higher wins
2. If equal, compare minor: higher wins
3. If equal, compare patch: higher wins
4. If equal, compare prerelease: version with prerelease < version without

**Determination Rules** (from FR-005):
| Commit Pattern | Version Increment | Example |
|----------------|-------------------|---------|
| `feat:` | Minor (0.x.0) | 1.2.3 → 1.3.0 |
| `fix:` | Patch (0.0.x) | 1.2.3 → 1.2.4 |
| `BREAKING CHANGE:` or `feat!:` | Major (x.0.0) | 1.2.3 → 2.0.0 |
| `chore:`, `docs:`, `style:`, `refactor:`, `test:` | No release | 1.2.3 → 1.2.3 |

**No Custom Implementation Required**: Semantic-release handles all version calculation logic.

---

## Workflow State Machine

While individual entities don't require custom state management, the overall CI/CD process follows this state machine:

```
PR Created
    ↓
[Test Run: pending]
    ↓
[Test Run: in_progress] → Tests executing
    ↓                    ↓
    ↓                    ↓ (on failure)
    ↓                    ↓
    ↓              [Test Run: failure] → PR blocked
    ↓                    ↓
    ↓                    ↓ (fix pushed)
    ↓                    ↓
    ↓              [Test Run: pending] ← (restart)
    ↓
[Test Run: success] → PR approved
    ↓
PR Merged to main
    ↓
[Release: analyzing commits] → Semantic-release running
    ↓
[Release: version calculated] → e.g., 1.2.3 → 1.3.0
    ↓
[Release: tag created] → Git tag v1.3.0
    ↓
[Release: published] → GitHub Release created
    ↓
[Artifact: building] → Tarball creation in progress
    ↓
[Artifact: uploaded] → Artifact attached to release
    ↓
DONE → Release ready for deployment
```

## Data Storage and Retention

All data is stored and managed by GitHub's platform:

| Entity    | Storage Location               | Retention Policy                        |
| --------- | ------------------------------ | --------------------------------------- |
| Test Run  | GitHub Actions (workflow runs) | 90 days (FR-011)                        |
| Test Logs | GitHub Actions (job logs)      | 90 days (FR-011)                        |
| Release   | GitHub Releases                | Indefinite (until manually deleted)     |
| Artifact  | GitHub Release Assets          | Indefinite (tied to release)            |
| Version   | Git Tags                       | Indefinite (part of repository history) |

## No Database Required

This feature does not require:

- Database schema or migrations
- ORM models
- Data access layers
- Caching strategies
- Backup/restore procedures

All data persistence is handled by GitHub's infrastructure.

## Integration Points

### GitHub Actions API

Workflows interact with GitHub APIs automatically via `GITHUB_TOKEN`:

- **Actions API**: Query workflow run status, download logs
- **Releases API**: Create releases, upload assets
- **Git Data API**: Create tags, read commit history
- **Pull Requests API**: Update status checks

### Existing Application Data

Workflows do **not** interact with application data:

- Do not read/write to `data/` directory (trivia session storage)
- Do not modify application configuration
- Do not access Discord API
- Operate independently of runtime application state

## Validation Integration

### Test Coverage Data

Coverage data flows from pytest → workflow → GitHub status check:

```
pytest-cov
    ↓ (generates)
.coverage file + htmlcov/
    ↓ (parsed by)
Workflow step: coverage report
    ↓ (extracts)
Coverage percentage (e.g., 86.92%)
    ↓ (validates)
Check: >= 80%? (FR-002)
    ↓ (updates)
PR status check (✅ or ❌)
```

### Semantic Version Data

Version data flows from commits → semantic-release → Git tag → Release:

```
Git commit messages
    ↓ (parsed by)
@semantic-release/commit-analyzer
    ↓ (determines)
Version bump type (major/minor/patch)
    ↓ (calculates)
New version number (e.g., v1.3.0)
    ↓ (creates)
Git tag + GitHub Release
    ↓ (triggers)
Artifact workflow
```

## Summary

This feature requires **zero custom data models**. All entities are conceptual representations of existing GitHub platform features. Implementation consists entirely of workflow orchestration using GitHub Actions YAML configuration files.
